import utilsimport numpy as npimport matplotlib.pyplot as pltimport pandas as pdimport timeround = 1epoch = 16dir_train = 'train_data.csv'dir_test = 'test_data.csv'activation = 'ReLU'optimization = 'Adamoptimizer'regularization = 0.1def make_dataset(pd_frame):    """    :param pd_frame:    :return:  train , valid, test    """    res = []    for i in range(len(pd_frame)):        res.append([[pd_frame.iloc[i]['x1'], pd_frame.iloc[i]['x2'], pd_frame.iloc[i]['x3']], pd_frame.iloc[i]['y']])    return res[:505], res[505:605], res[605:]def data_process(raw_data):    """    :param raw_data:    :return:  normalized raw_data    """    mx1, mn1 = max(raw_data['x1']), min(raw_data['x1'])    mx2, mn2 = max(raw_data['x2']), min(raw_data['x2'])    mx3, mn3 = max(raw_data['x3']), min(raw_data['x3'])    mxy, mny = max(raw_data['y']), min(raw_data['y'])    print(mx1,mn2)    print(mx2,mn2)    print(mx3, mn3)    print(mxy, mny)    for i in range(len(raw_data)):        raw_data['x1'].iloc[i] = (raw_data['x1'].iloc[i] - mn1) / (mx1 - mn1)        raw_data['x2'].iloc[i] = (raw_data['x2'].iloc[i] - mn2) / (mx2 - mn2)        raw_data['x3'].iloc[i] = (raw_data['x3'].iloc[i] - mn3) / (mx3 - mn3)        if np.isnan(raw_data['y'].iloc[i]):            raw_data['y'].iloc[i] = mny        else:            raw_data['y'].iloc[i] = (raw_data['y'].iloc[i] - mny) / (mxy - mny)    return raw_datadef cal_loss(batch, net):    batch_x, batch_y = [], []    for j in range(len(batch)):        batch_x.append([batch[j][0]])        batch_y.append([[batch[j][1]]])    total_loss = utils.valid_forward(batch_x, batch_y, net)    return total_lossdef train():    print('Loading data !')    train_csv, test_csv = pd.read_csv(dir_train), pd.read_csv(dir_test)    raw_data = train_csv.append(test_csv,sort = False)    max_, min_ = max(raw_data['y']), min(raw_data['y'])    train_data, valid_data, test_data = make_dataset(data_process(raw_data))    REGULARIZATION = regularization / len(train_data)    try:        net = utils.load_model('model2.npy')        print('Successfully load model !')    except:        print('Initialize the model parameters !')        net = [utils.get_layer(3, 5, activation=activation, optimizer=optimization, regularization=REGULARIZATION),               utils.get_layer(5, 2, 'ReLU', optimizer=optimization, regularization=REGULARIZATION),               utils.get_layer(2, 1, 'linear', optimizer=optimization, regularization=REGULARIZATION)]    valid_loss_record = []    test_loss_record = []    for q in range(epoch):        batch = utils.batch(train_data, True)        train_batch, valid_batch = utils.batch(train_data, True), utils.batch(valid_data, True)        print('training begins !')        time_start = time.time()        train_loss, valid_loss = 0, 0        for p in range(round):            for i in range(len(batch)):                net, _ = utils.train([batch[i][0]], [[batch[i][1]]], net, learning_rate=0.01, decay_rate = 0.99)            train_loss, valid_loss = cal_loss(train_batch, net), cal_loss(valid_batch, net)            print('epoch : ' + str(q) + '  train_loss:' + str(train_loss / len(train_batch)) + '  valid_loss:' + str(valid_loss / len(valid_batch)))        valid_loss_record.append(train_loss / len(train_batch))        test_loss_record.append(valid_loss / len(valid_batch))    time_end = time.time()    print('Train finished in ' +  str((time_end - time_start) * 60) + ' seconds !')    validation(valid_data, net, max_, min_)    plt.plot(valid_loss_record, label='train',color='r')    plt.plot(test_loss_record, label='valid', color='b')    plt.savefig('loss.jpg')    plt.show()    return netdef validation(data, net, max_, min_):    print('length: ' + str(len(data)))    out = []    prediction = []    validation = []    ground_truth = []    for i in range(len(data)):        out.append(utils.predict([data[i][0]], net)[0])        prediction.append((max_ - min_) * utils.predict([data[i][0]], net)[0] + min_)    for i in range(len(data)):        validation.append(data[i][1])        ground_truth.append((max_ - min_) * data[i][1] + min_)    print(validation)    print(out)    print(ground_truth)    print(prediction)    MSE_loss_raw = np.power(np.array(validation) - np.array(out), 2)    MSE_loss = np.power(np.array(prediction) - np.array(ground_truth), 2)    avg_MSE_loss_raw = np.sum(MSE_loss_raw) / len(data)    avg_MSE_loss = np.sum(MSE_loss) / len(data)    MSE_loss.sort()    step = (max(MSE_loss) - min(MSE_loss)) / 5    section = [min(MSE_loss), min(MSE_loss) + step, min(MSE_loss) + 2*step, min(MSE_loss) + 3*step,  min(MSE_loss) + 4*step, max(MSE_loss)]    group_names = [ str(int((min(MSE_loss) + step) * 100) / 100 ),                    str(int((min(MSE_loss) + 2*step) * 100 ) / 100),                    str(int((min(MSE_loss) + 3*step) * 100 ) / 100),                    str(int((min(MSE_loss) + 4*step) * 100 ) / 100),                    str(int((max(MSE_loss) * 100)) / 100)]    cuts = pd.cut(MSE_loss, section, labels=group_names)    cuts.value_counts().plot(kind='bar')    plt.title('bar')    plt.show()    plt.plot(MSE_loss)    plt.title('mse_loss')    plt.show()    square_MSE_loss_raw = np.sum(np.power(MSE_loss_raw - avg_MSE_loss_raw, 2))    square_MSE_loss= np.sum(np.power(MSE_loss - avg_MSE_loss, 2))    error = []    diff = abs(np.array(ground_truth) - np.array(prediction))    for i in range(len(ground_truth)):        error.append(diff[i] / ground_truth[i])    diff = diff.tolist()    diff.sort()    avg_abs = np.mean(diff)    print(diff)    print('avg_abs: ' + str(avg_abs))    plt.plot(diff)    plt.title('diff')    plt.show()    print('avg_loss_raw: ' + str(avg_MSE_loss_raw))    print('avg_loss: ' + str(avg_MSE_loss))    print('squre_MSE_loss: ' + str(square_MSE_loss))    print('avg_%_error: ' + str(avg_abs / 2.975 ))    var = np.var(diff)    print('var: ' + str(var))    print('avg_error: ',np.mean(error))    if np.mean(error) < 0.05:        utils.save_model(net)        print('model saved !')if __name__ == '__main__':    net = train()